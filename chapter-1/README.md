
1. 小さくまとめてわかりやすくする
    - なぜソフトウェアの変更は大変なのか？
    - プログラムの変更が楽になる書き方
    - 小さなクラスでわかりやすく安全に
    - 複雑さを閉じ込める


- 設計とは
    - どこに何が書いてあるのかがわかりやすくし、修正や拡張をしやすくするもの
    - 悪い設計
        - 変更時の影響範囲が大きい

- プログラムの変更が楽になる書き方【小さくまとめる】
    - わかりやすい名前を使う
        - 業務で使用している言葉をそのままコードに反映する
        - 省略しない
    - 長いメソッドは段落に分けて読みやすくする
        - 目的毎に変数を用意する
    - 目的別の変数を使用する
        - 破壊的代入は副作用の元凶
    - 段落をメソッドとして独立させる = メソッドの抽出
        - 元のコードがシンプルになり読みやすくなる
        - メソッドの名前からコードの糸を理解しやすくなる
        - メソッド内に変更の影響を閉じ込めやすくなる
        - 再利用性が高まる（メソッド化していないと同じ処理があちこちに書かれる）
    - 業務の関心毎に対応したクラスを作る
        - ValueObjectを作成する
            - 基本データ型のインスタンス変数を1, 2個持つ小さなクラス
            - 業務用語をそのまま使用する（業務の説明書を作成するイメージ）
            - 何をやっているかをイメージしやすくする
            - 例）電話番号
                - 数字のみ使用可能
                - 合計の桁数は10桁など

- 複雑さを閉じ込める
    - 独自のコレクションを作成する
        - 配列・コレクションはコードを複雑にする
            - ループ処理のロジック？
            - 要素数が変化する
            - 個数の要素の内容が変化する
            - ゼロ件の場合の処理
                - 毎回`is_null`とかで対応していて見辛いコードができている
            - 要素数の最大数の制限
        - getxxのメソッドがあったら立ち止まる
            - そのクラスにロジックを含めることはできないか？



Q. ビジネスロジックが大抵の場合データベースと関連してSQLで実現できてしまう
例）返却期限切れの判定 => SQLでできる上に、エンティティはインフラ層に依存しないような形にしたいので結果getterだけのデータの入れ子になる

Q2. 【ValueObjectを作成する】について
Laravelにおいて正しいデータの保証はFormRequestが行えるのでバリデーションは不要？

Q3. 【ValueObjectを作成する】について
ValueObjectを作成しすぎると（分けすぎると）データベース操作が大変になるが対処法はないのか？

Q4. 【独自のコレクションを作成する】について p40
基本操作だけを行うBaseのCollectionを作成して、継承先で引数の型を指定することはできるのか？

Q5. 【独自のコレクションを作成する】について p43
不変にこだわる理由がわからない
-> 副作用を減らすため